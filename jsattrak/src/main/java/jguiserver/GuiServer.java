/*
 * GuiServer.java
 * =====================================================================
 *   This file is part of JSatTrak.
 *
 *   Copyright 2007-2013 Shawn E. Gano
 *   
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *   
 *       http://www.apache.org/licenses/LICENSE-2.0
 *   
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 * =====================================================================
 *
 * A multi-threaded server to support clients running commands  on the same bean shell interperter
 * 
 * note: may want to add constructor to send in interpertor and title (and maybe location)
 * note: may want to add ability to disconnect a connection by selecting it in the table?
 */

package jguiserver;

import bsh.Interpreter;
import java.awt.Color;
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.List;
import java.util.Vector;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.table.DefaultTableModel;
import org.jdesktop.swingx.decorator.ColorHighlighter;
import org.jdesktop.swingx.decorator.HighlightPredicate;

/**
 *
 * @author  Shawn Gano
 */
public class GuiServer extends javax.swing.JFrame
{
    
    Interpreter bsh;
    
    CommandServerThread commandServer;
    
    String appName = "JSatTrak Command Server";
    String appAuthor = "Shawn Gano";        
    String version = "v1.0 (21 Mar 2008)";
    
    /** Creates new form GuiServer
     * @param bsh bean shell interperator
     */
    public GuiServer(Interpreter bsh)
    {
        this.setTitle("JSatTrak Command Server");
        
        initComponents();
        statusColorBox.setBackground(Color.RED);
        
        connectionjXTable.setColumnControlVisible(true);
        connectionjXTable.addHighlighter(new ColorHighlighter(HighlightPredicate.EVEN, Color.WHITE, Color.black)); // even, background, foregrond
        connectionjXTable.addHighlighter(new ColorHighlighter(HighlightPredicate.ODD, new Color(229, 229, 229), Color.black)); // odd, background, foregrond
//        connectionjXTable.addHighlighter(AlternateRowHighlighter.genericGrey);
        
        //connectionjXTable.setShowGrid(true);
        
        this.bsh = bsh; // set interperter
        
        try
        {
            InetAddress addr = InetAddress.getLocalHost();

            // Get IP Address
            byte[] ipAddr = addr.getAddress();
            
            hostIPTextField.setText( addr.getHostAddress());

            // Get hostname
            //String hostname = addr.getHostName();
        }
        catch (UnknownHostException e)
        {
        }
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        statusBarPanel = new javax.swing.JPanel();
        statusColorBox = new javax.swing.JPanel();
        statusMessageLabel = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        hostIPTextField = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        portTextField = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        connectionjXTable = new org.jdesktop.swingx.JXTable();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        startStopServerMenuItem = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        exitMenuItem = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        statusColorBox.setBackground(new java.awt.Color(255, 0, 0));
        statusColorBox.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout statusColorBoxLayout = new javax.swing.GroupLayout(statusColorBox);
        statusColorBox.setLayout(statusColorBoxLayout);
        statusColorBoxLayout.setHorizontalGroup(
            statusColorBoxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 21, Short.MAX_VALUE)
        );
        statusColorBoxLayout.setVerticalGroup(
            statusColorBoxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 15, Short.MAX_VALUE)
        );

        statusMessageLabel.setForeground(new java.awt.Color(102, 102, 102));
        statusMessageLabel.setText("Server Not Running.");

        javax.swing.GroupLayout statusBarPanelLayout = new javax.swing.GroupLayout(statusBarPanel);
        statusBarPanel.setLayout(statusBarPanelLayout);
        statusBarPanelLayout.setHorizontalGroup(
            statusBarPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(statusBarPanelLayout.createSequentialGroup()
                .addComponent(statusColorBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(statusMessageLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 333, Short.MAX_VALUE))
        );
        statusBarPanelLayout.setVerticalGroup(
            statusBarPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(statusColorBox, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(statusMessageLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 17, Short.MAX_VALUE)
        );

        jLabel1.setText("IP:");

        hostIPTextField.setEditable(false);

        jLabel2.setText("Port:");

        portTextField.setText("2249");

        jLabel3.setText("Connections:");

        connectionjXTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][]
            {

            },
            new String []
            {
                "ID", "Client IP ", "Connection Created"
            }
        )
        {
            Class[] types = new Class []
            {
                java.lang.Integer.class, java.lang.Object.class, java.lang.Object.class
            };
            boolean[] canEdit = new boolean []
            {
                false, false, false
            };

            public Class getColumnClass(int columnIndex)
            {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex)
            {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(connectionjXTable);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(hostIPTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 186, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(portTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jLabel3))
                .addContainerGap(47, Short.MAX_VALUE))
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 360, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2)
                    .addComponent(portTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(hostIPTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 195, Short.MAX_VALUE))
        );

        jMenu1.setText("File");

        startStopServerMenuItem.setText("Start Server");
        startStopServerMenuItem.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                startStopServerMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(startStopServerMenuItem);
        jMenu1.add(jSeparator1);

        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                exitMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(exitMenuItem);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Help");

        aboutMenuItem.setText("About...");
        aboutMenuItem.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                aboutMenuItemActionPerformed(evt);
            }
        });
        jMenu2.add(aboutMenuItem);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(statusBarPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(5, 5, 5)
                .addComponent(statusBarPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void startStopServerMenuItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_startStopServerMenuItemActionPerformed
    {//GEN-HEADEREND:event_startStopServerMenuItemActionPerformed
        
        if(statusColorBox.getBackground() == Color.RED)
        {
            // start a new server
            commandServer = new CommandServerThread();
            commandServer.execute();
        }
        else // stop server
        {
            commandServer.setListening(false);
        }
        
}//GEN-LAST:event_startStopServerMenuItemActionPerformed

    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_exitMenuItemActionPerformed
    {//GEN-HEADEREND:event_exitMenuItemActionPerformed
        //System.exit(0); 
        commandServer.setListening(false); //stop server
        this.setVisible(false); // set invisible
}//GEN-LAST:event_exitMenuItemActionPerformed

    private void aboutMenuItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_aboutMenuItemActionPerformed
    {//GEN-HEADEREND:event_aboutMenuItemActionPerformed
        // show dialog with about info
        // version
        JOptionPane.showMessageDialog(this, appName + "\n\nby: " + appAuthor + "\n\n" + version);
    }//GEN-LAST:event_aboutMenuItemActionPerformed
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        java.awt.EventQueue.invokeLater(new Runnable()
        {
            public void run()
            {
                new GuiServer(new Interpreter()).setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutMenuItem;
    private org.jdesktop.swingx.JXTable connectionjXTable;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JTextField hostIPTextField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JTextField portTextField;
    private javax.swing.JMenuItem startStopServerMenuItem;
    private javax.swing.JPanel statusBarPanel;
    private javax.swing.JPanel statusColorBox;
    private javax.swing.JLabel statusMessageLabel;
    // End of variables declaration//GEN-END:variables
 
    
    
    // Command Server Thread
    //First Obj - the result type returned by this SwingWorker's  doInBackground and get methods
    //Second Obj - the type used for carrying out intermediate results by this SwingWorker's publish and process methods
    protected class CommandServerThread extends SwingWorker<Object, Object>
    {
        boolean listening = false; // if socket is listening
        Vector<CommandMultiServerThread> connectionVector = new Vector<CommandMultiServerThread>(); 
        
        // constructor, can take in objects needed
        public CommandServerThread()
        {
            // can access GUI from here too
            statusColorBox.setBackground(Color.GREEN);
            startStopServerMenuItem.setText("Stop Server");
            statusMessageLabel.setText("Server Accepting Connections.");
            portTextField.setEditable(false);
            
        }
        
        public Object doInBackground()
        {
            // to send something to be updated in gui use:
            // publish((Object) obj);
            
            ServerSocket serverSocket = null;
            listening = true;
            
            int nextConnectionID = 0;

            try 
            {
                int port = Integer.parseInt( portTextField.getText() );
                
                serverSocket = new ServerSocket(port);
                serverSocket.setSoTimeout(3000); // 3 sec delay in seeing if server should close
            } 
            catch (IOException e) 
            {
                System.err.println("Could not listen on port:.");
                //System.exit(-1);
            }

            while (listening)
            {
                try
                {
                    // wait for a connection
                    Socket newSocket = serverSocket.accept();
                    
                    // make a new connection thread and add it to Vector
                    // passes outer class's bsh interperator
                    CommandMultiServerThread newConnection = new CommandMultiServerThread(newSocket, bsh, nextConnectionID, this);
                    newConnection.start();
                    
                    connectionVector.add(newConnection);
                    nextConnectionID ++;
                    
                    publish("New Connection Made"); // trigger process function to be called when time permits updating of GUI
                }
                catch(Exception e)
                {
                    //System.out.println("Socket Timeout");
                }
            }
            
            try
            {
                // first close all the connections
                for(CommandMultiServerThread s : connectionVector)
                {
                    s.close();
                }
                // now close socket
                serverSocket.close();
            }
            catch(Exception e)
            {
                System.out.println("Couldn't close server");
            }

            
            return null;
        }
        
        // Receives data chunks from the publish method asynchronously on the Event Dispatch Thread.
        // can access swing components
        protected void process(List<Object> chunks)
        {
            // update JXTable
            updateTable();           
        }
        
        protected void updateTable()
        {
             // clear table
            for (int i = connectionjXTable.getModel().getRowCount() - 1; i >= 0; i--)
            {
                ((DefaultTableModel) connectionjXTable.getModel()).removeRow(i);
            }
            
            // update new info: ID, IP, date, message count
            for(CommandMultiServerThread s : connectionVector)
            {
                ((DefaultTableModel)connectionjXTable.getModel()).addRow( new Object[] {s.getConnectionID(),s.getClientIP(),s.getIniDate()});
            }
        }
        
        // what do to when done (can access swing components
        protected void done()
        {
            statusColorBox.setBackground(Color.RED);
            startStopServerMenuItem.setText("Start Server");
            statusMessageLabel.setText("Server Not Running.");
            portTextField.setEditable(true);
        }
        
        public boolean isListening()
        {
            return listening;
        }

        public void setListening(boolean listening)
        {
            this.listening = listening;
            //System.out.println("here");
        }
        
        public void processConnectionClose(CommandMultiServerThread conn)
        {
            connectionVector.remove(conn);
            updateTable();
        }
        
    } // CommandServerThread
    
    
    
}
